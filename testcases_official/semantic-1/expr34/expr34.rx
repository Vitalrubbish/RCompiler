/*
Test Package: Semantic-1
Test Target: expr
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Fail
Comment: Complex expression error: Missing semicolon after statement - hash table with quadratic probing, collision resolution, and load factor analysis
*/

struct HashTableEntry {
    key: i32,
    value: i32,
    is_occupied: bool,
    is_deleted: bool,
}

impl HashTableEntry {
    fn new() -> HashTableEntry {
        HashTableEntry {
            key: 0,
            value: 0,
            is_occupied: false,
            is_deleted: false,
        }
    }
    
    fn set(&mut self, k: i32, v: i32) {
        self.key = k;
        self.value = v;
        self.is_occupied = true;
        self.is_deleted = false;
    }
    
    fn delete(&mut self) {
        self.is_occupied = false;
        self.is_deleted = true;
    }
}

fn hash_function(key: i32, table_size: i32) -> i32 {
    let hash = {
        let temp = key * key;
        let normalized = temp % 1000;
        let adjusted = if normalized < 0 { -normalized } else { normalized };
        adjusted % table_size
    };
    return hash;
}

fn quadratic_probe(base_hash: i32, attempt: i32, table_size: i32) -> i32 {
    let probe_offset = {
        let square = attempt * attempt;
        let linear = attempt * 3;
        square + linear
    };
    let final_hash = (base_hash + probe_offset) % table_size;
    return if final_hash < 0 { final_hash + table_size } else { final_hash };
}

fn insert_with_collision_resolution(table: &mut [HashTableEntry; 13], key: i32, value: i32) -> bool {
    let base_hash = hash_function(key, 13);
    let mut attempt = 0;
    
    loop {
        if attempt >= 13 {
            break;
        }
        
        let probe_hash = quadratic_probe(base_hash, attempt, 13);
        let entry = &mut table[probe_hash];
        
        if !entry.is_occupied || entry.is_deleted {
            entry.set(key, value);
            return true;
        } else if entry.key == key {
            entry.value = value;
            return true;
        }
        
        attempt = attempt + 1;
    }
    
    return false;
}

fn lookup_with_probing(table: &[HashTableEntry; 13], key: i32) -> i32 {
    let base_hash = hash_function(key, 13);
    let mut attempt = 0;
    
    loop {
        if attempt >= 13 {
            break;
        }
        
        let probe_hash = quadratic_probe(base_hash, attempt, 13);
        let entry = &table[probe_hash];
        
        if !entry.is_occupied && !entry.is_deleted {
            return -1;
        } else if entry.is_occupied && entry.key == key {
            return entry.value;
        }
        
        attempt = attempt + 1;
    }
    
    return -1;
}

fn calculate_load_factor_metrics(table: &[HashTableEntry; 13]) -> i32 {
    let mut occupied_count = 0;
    let mut deleted_count = 0;
    let mut collision_estimate = 0;
    
    let mut index = 0;
    loop {
        if index >= 13 {
            break;
        }
        
        let entry = &table[index];
        if entry.is_occupied {
            occupied_count = occupied_count + 1;
            let expected_hash = hash_function(entry.key, 13);
            if expected_hash != index {
                collision_estimate = collision_estimate + 1;
            }
        } else if entry.is_deleted {
            deleted_count = deleted_count + 1;
        }
        
        index = index + 1;
    }
    
    let metrics = {
        let load_factor = occupied_count * 100 / 13;
        let fragmentation = deleted_count * 50;
        let collision_penalty = collision_estimate * 25;
        let total = load_factor + fragmentation + collision_penalty;
        if total > 200 {
            total % 100
        } else {
            total + 50
        }
    };
    
    return metrics;
}

fn main() {
    let mut hash_table: [HashTableEntry; 13] = [
        HashTableEntry::new(), HashTableEntry::new(), HashTableEntry::new(), HashTableEntry::new(),
        HashTableEntry::new(), HashTableEntry::new(), HashTableEntry::new(), HashTableEntry::new(),
        HashTableEntry::new(), HashTableEntry::new(), HashTableEntry::new(), HashTableEntry::new(),
        HashTableEntry::new(),
    ];
    
    let keys = [17, 23, 41, 59, 67, 83, 97, 101, 113, 127];
    let values = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100];
    
    let mut insertion_success_count = 0;
    let mut key_index = 0;
    
    loop {
        if key_index >= 10 {
            break;
        }
        
        let current_key = keys[key_index];
        let current_value = values[key_index];
        let success = insert_with_collision_resolution(&mut hash_table, current_key, current_value);
        
        if success {
            insertion_success_count = insertion_success_count + 1;
        }
        
        key_index = key_index + 1;
    }
    
    let mut lookup_sum = 0;
    let mut lookup_index = 0;
    
    loop {
        if lookup_index >= 10 {
            break;
        }
        
        let lookup_key = keys[lookup_index];
        let found_value = lookup_with_probing(&hash_table, lookup_key);
        
        if found_value > 0 {
            lookup_sum = lookup_sum + found_value;
        }
        
        lookup_index = lookup_index + 1;
    }
    
    let load_metrics = calculate_load_factor_metrics(&hash_table);
    
    let final_result = {
        let insertion_weight = insertion_success_count * 10;
        let lookup_weight = lookup_sum / 5;
        let metrics_weight = load_metrics * 2;
        let combined = insertion_weight + lookup_weight + metrics_weight;
        let processed = {
            let temp = combined % 500;
            if temp > 250 {
                temp - 100
            } else {
                temp + 75
            }
        };
        processed
    };
    
    if final_result > 0 && final_result != insertion_success_count && final_result < 10000 {
        let optimized_output = {
            let base = final_result;
            let factor = if base % 7 == 0 {
                3
            } else if base % 7 == 1 {
                5
            } else if base % 7 == 2 {
                7
            } else {
                2
            };
            (base * factor) % 1000
        };
        printInt(optimized_output);
    } else {
        let fallback = 314;
        if fallback > final_result {
            printInt(fallback - final_result);
        } else {
            printInt(fallback + final_result)
        }
    }
    exit(0);
}
