/*
Test Package: Semantic-1
Test Target: misc
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Fail
Comment: Miller-Rabin primality test with generic type parameter mismatch error
*/

// Miller-Rabin probabilistic primality test algorithm
// Uses repeated squaring and modular arithmetic

trait NumberOperations<T> {
    fn power_mod(base: T, exp: T, modulus: T) -> T;
    fn is_even(n: T) -> bool;
}

impl NumberOperations<i32> for i32 {
    fn power_mod(base: i32, exp: i32, modulus: i32) -> i32 {
        if modulus == 1 {
            return 0;
        }
        
        let mut result = 1;
        let mut base_mod = base % modulus;
        let mut exponent = exp;
        
        while exponent > 0 {
            if exponent % 2 == 1 {
                result = ((result as i64 * base_mod as i64) % modulus as i64) as i32;
            }
            exponent = exponent / 2;
            base_mod = ((base_mod as i64 * base_mod as i64) % modulus as i64) as i32;
        }
        
        return result;
    }
    
    fn is_even(n: i32) -> bool {
        return n % 2 == 0;
    }
}

struct MillerRabinTest {
    witness_count: i32,
    accuracy_threshold: i32,
}

// Decompose n-1 as d * 2^r where d is odd
fn decompose_number(n: i32) -> (i32, i32) {
    let mut d = n - 1;
    let mut r = 0;
    
    while d % 2 == 0 {
        d = d / 2;
        r += 1;
    }
    
    return (d, r);
}

// Single Miller-Rabin test with witness a
fn miller_rabin_witness_test(n: i32, a: i32, d: i32, r: i32) -> bool {
    // Compute a^d mod n
    let mut x = i32::power_mod(a, d, n);
    
    if x == 1 || x == n - 1 {
        return true;  // Probably prime
    }
    
    // Repeat r-1 times
    let mut i = 0;
    while i < r - 1 {
        x = i32::power_mod(x, 2, n);
        
        if x == n - 1 {
            return true;  // Probably prime
        }
        
        i += 1;
    }
    
    return false;  // Composite
}

// Main Miller-Rabin primality test
fn miller_rabin_test<T>(n: T, witnesses: [i32; 8]) -> bool {  

    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if NumberOperations::<T>::is_even(n) {
        return false;
    }
    
    let n_i32 = n as i32; 
    let (d, r) = decompose_number(n_i32);
    
    let mut witness_index = 0;
    while witness_index < 8 {
        let a = witnesses[witness_index as usize];
        
        if a >= n_i32 {
            witness_index += 1;
            continue;
        }
        
        if !miller_rabin_witness_test(n_i32, a, d, r) {
            return false;  // Definitely composite
        }
        
        witness_index += 1;
    }
    
    return true;  // Probably prime
}

// Test multiple numbers for primality
fn comprehensive_primality_test() -> i32 {
    let common_witnesses = [2, 3, 5, 7, 11, 13, 17, 19];
    let mut prime_count = 0;
    let mut composite_sum = 0;
    
    let mut test_number = 100;
    while test_number <= 200 {
        // Error occurs here: calling generic function with i32 but expecting different type
        let is_probably_prime = miller_rabin_test(test_number, common_witnesses);
        
        if is_probably_prime {
            prime_count += 1;
        } else {
            composite_sum += test_number % 100;  // Keep sum manageable
        }
        
        // Additional verification using trial division for small numbers
        if test_number < 150 {
            let mut trial_divisor = 2;
            let mut is_trial_prime = true;
            
            while trial_divisor * trial_divisor <= test_number {
                if test_number % trial_divisor == 0 {
                    is_trial_prime = false;
                    break;
                }
                trial_divisor += 1;
            }
            
            // Cross-validation between methods
            if is_probably_prime != is_trial_prime && test_number > 2 {
                composite_sum += 1;  // Discrepancy penalty
            }
        }
        
        test_number += 1;
    }
    
    return prime_count * 10 + composite_sum;
}

// Fermat primality test for comparison (simple version)
fn fermat_primality_test(n: i32, iterations: i32) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    
    let mut iter = 0;
    while iter < iterations {
        let a = 2 + (iter % 10);  // Simple witness selection
        
        if a >= n {
            iter += 1;
            continue;
        }
        
        let result = i32::power_mod(a, n - 1, n);
        if result != 1 {
            return false;  // Composite
        }
        
        iter += 1;
    }
    
    return true;  // Probably prime
}

// Compare Miller-Rabin with Fermat test
fn compare_primality_tests() -> i32 {
    let mut comparison_score = 0;
    let mut test_num = 50;
    
    while test_num < 100 {
        let miller_result = comprehensive_primality_test();  // This will fail at compilation
        let fermat_result = fermat_primality_test(test_num, 5);
        
        // Scoring based on agreement between methods
        if fermat_result {
            comparison_score += test_num % 10;
        }
        
        test_num += 7;  // Skip some numbers for efficiency
    }
    
    return comparison_score + miller_result;
}

fn main() {
    let primality_result = comprehensive_primality_test();
    let comparison_result = compare_primality_tests();
    let final_score = primality_result + comparison_result;
    printInt(final_score);
    exit(0);
}
