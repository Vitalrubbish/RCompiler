/*
Test Package: Semantic-1
Test Target: expr
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Fail
Comment: Complex expression error: Missing closing parenthesis in function call - recursive fibonacci with memoization, binary tree operations, and complex nested expressions
*/

struct BinaryTreeNode {
    value: i32,
    left_child: bool,
    right_child: bool,
}

impl BinaryTreeNode {
    fn new(val: i32) -> BinaryTreeNode {
        BinaryTreeNode {
            value: val,
            left_child: false,
            right_child: false,
        }
    }
}

fn fibonacci_tree_height(n: i32, memo: [i32; 20]) -> i32 {
    if n <= 1 {
        return n;
    }
    
    if memo[n] != -1 {
        return memo[n];
    }
    
    let left_height = fibonacci_tree_height(n - 1, memo);
    let right_height = fibonacci_tree_height(n - 2, memo);
    
    let current_height = {
        let temp_sum = left_height + right_height;
        let normalized = temp_sum % 100;
        if normalized > 50 {
            normalized - 25
        } else {
            normalized + 10
        }
    };
    
    memo[n] = current_height;
    return current_height;
}

fn calculate_tree_complexity(nodes: [BinaryTreeNode; 5]) -> i32 {
    let mut total_complexity = 0;
    let mut index = 0;
    
    loop {
        if index >= 5 {
            break;
        }
        
        let node = &nodes[index];
        let node_value = node.value;
        let complexity_factor = {
            let base = node_value * node_value;
            let modifier = if node.left_child { 2 } else { 1 };
            let adjusted = base * modifier;
            if node.right_child {
                adjusted + 5
            } else {
                adjusted - 3
            }
        };
        
        total_complexity = total_complexity + complexity_factor;
        index = index + 1;
    }
    
    return total_complexity;
}

fn main() {
    let mut memo_array: [i32; 20] = [-1; 20];
    let mut tree_nodes: [BinaryTreeNode; 5] = [
        BinaryTreeNode::new(1),
        BinaryTreeNode::new(3),
        BinaryTreeNode::new(5),
        BinaryTreeNode::new(7),
        BinaryTreeNode::new(9),
    ];
    
    tree_nodes[0].left_child = true;
    tree_nodes[0].right_child = false;
    tree_nodes[1].left_child = true;
    tree_nodes[1].right_child = true;
    tree_nodes[2].left_child = false;
    tree_nodes[2].right_child = true;
    tree_nodes[3].left_child = true;
    tree_nodes[3].right_child = true;
    tree_nodes[4].left_child = false;
    tree_nodes[4].right_child = false;
    
    let fib_result = fibonacci_tree_height(8, memo_array);
    let complexity_result = calculate_tree_complexity(tree_nodes);
    
    let combined_result = {
        let weighted_fib = fib_result * 3;
        let weighted_complexity = complexity_result / 2;
        let sum = weighted_fib + weighted_complexity;
        if sum > 100 {
            sum % 50
        } else {
            sum * 2
        }
    };
    
    let final_output = if combined_result > 0 {
        let temp = combined_result + 1;
        if temp % 2 == 0 {
            temp / 2
        } else {
            temp * 3 + 1
        }
    } else {
        42
    };
    
    if final_output != 0 && final_output > 0 {
        printInt(final_output;
    } else {
        printInt(0);
    }
    exit(0);
}
