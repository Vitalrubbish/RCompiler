/*
Test Package: Semantic-1
Test Target: misc
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Fail
Comment: Persistent Segment Tree with lazy propagation and path copying with function name collision error
*/

// Persistent Segment Tree with Lazy Propagation for Range Updates
// Supports historical queries with path copying and efficient memory management

struct SegmentNode {
    left_child: i32,    // Index of left child (-1 if leaf)
    right_child: i32,   // Index of right child (-1 if leaf)
    sum_value: i64,     // Sum of range
    lazy_add: i64,      // Lazy propagation value for addition
    lazy_mult: i64,     // Lazy propagation value for multiplication
    version_id: i32,    // Version when this node was created
    range_left: i32,    // Left boundary of range
    range_right: i32,   // Right boundary of range
}

struct PersistentSegmentTree {
    nodes: [SegmentNode; 5000],
    node_count: i32,
    version_roots: [i32; 100],  // Root node for each version
    current_version: i32,
    base_array: [i64; 200],
    array_size: i32,
}

// Initialize a new segment tree node
fn create_segment_node(left: i32, right: i32, version: i32) -> SegmentNode {
    SegmentNode {
        left_child: -1,
        right_child: -1,
        sum_value: 0,
        lazy_add: 0,
        lazy_mult: 1,  // Identity for multiplication
        version_id: version,
        range_left: left,
        range_right: right,
    }
}

// Create new node as copy of existing node (path copying for persistence)
fn copy_node(tree: &mut PersistentSegmentTree, original_idx: i32, new_version: i32) -> i32 {
    if tree.node_count >= 5000 {
        return -1;  // No more space
    }
    
    let new_idx = tree.node_count;
    tree.nodes[new_idx as usize] = tree.nodes[original_idx as usize];
    tree.nodes[new_idx as usize].version_id = new_version;
    tree.node_count += 1;
    
    return new_idx;
}

// Push lazy propagation values down to children
fn push_lazy_propagation(tree: &mut PersistentSegmentTree, node_idx: i32, version: i32) {
    if node_idx == -1 {
        return;
    }
    
    let node = &tree.nodes[node_idx as usize];
    let lazy_add = node.lazy_add;
    let lazy_mult = node.lazy_mult;
    
    if lazy_add == 0 && lazy_mult == 1 {
        return;  // No lazy values to push
    }
    
    let range_size = (node.range_right - node.range_left + 1) as i64;
    
    // Apply lazy values to current node
    tree.nodes[node_idx as usize].sum_value = 
        tree.nodes[node_idx as usize].sum_value * lazy_mult + lazy_add * range_size;
    
    // If not leaf, create new children and push values
    if node.left_child != -1 {
        let new_left = copy_node(tree, node.left_child, version);
        let new_right = copy_node(tree, node.right_child, version);
        
        tree.nodes[node_idx as usize].left_child = new_left;
        tree.nodes[node_idx as usize].right_child = new_right;
        
        // Push to left child
        if new_left != -1 {
            tree.nodes[new_left as usize].lazy_mult = 
                tree.nodes[new_left as usize].lazy_mult * lazy_mult;
            tree.nodes[new_left as usize].lazy_add = 
                tree.nodes[new_left as usize].lazy_add * lazy_mult + lazy_add;
        }
        
        // Push to right child
        if new_right != -1 {
            tree.nodes[new_right as usize].lazy_mult = 
                tree.nodes[new_right as usize].lazy_mult * lazy_mult;
            tree.nodes[new_right as usize].lazy_add = 
                tree.nodes[new_right as usize].lazy_add * lazy_mult + lazy_add;
        }
    }
    
    // Clear lazy values from current node
    tree.nodes[node_idx as usize].lazy_add = 0;
    tree.nodes[node_idx as usize].lazy_mult = 1;
}

// Build initial segment tree recursively
fn build_segment_tree_recursive(tree: &mut PersistentSegmentTree, 
                               left: i32, 
                               right: i32, 
                               version: i32) -> i32 {
    if tree.node_count >= 5000 {
        return -1;
    }
    
    let node_idx = tree.node_count;
    tree.nodes[node_idx as usize] = create_segment_node(left, right, version);
    tree.node_count += 1;
    
    if left == right {
        // Leaf node
        tree.nodes[node_idx as usize].sum_value = tree.base_array[left as usize];
        return node_idx;
    }
    
    let mid = (left + right) / 2;
    let left_child = build_segment_tree_recursive(tree, left, mid, version);
    let right_child = build_segment_tree_recursive(tree, mid + 1, right, version);
    
    tree.nodes[node_idx as usize].left_child = left_child;
    tree.nodes[node_idx as usize].right_child = right_child;
    
    // Calculate sum from children
    let left_sum = if left_child != -1 { tree.nodes[left_child as usize].sum_value } else { 0 };
    let right_sum = if right_child != -1 { tree.nodes[right_child as usize].sum_value } else { 0 };
    tree.nodes[node_idx as usize].sum_value = left_sum + right_sum;
    
    return node_idx;
}

// Range update with lazy propagation and path copying
fn update_range_recursive(tree: &mut PersistentSegmentTree,
                         node_idx: i32,
                         query_left: i32,
                         query_right: i32,
                         add_value: i64,
                         mult_value: i64,
                         version: i32) -> i32 {
    if node_idx == -1 {
        return -1;
    }
    
    let new_node = copy_node(tree, node_idx, version);
    push_lazy_propagation(tree, new_node, version);
    
    let node_left = tree.nodes[new_node as usize].range_left;
    let node_right = tree.nodes[new_node as usize].range_right;
    
    // No intersection
    if query_right < node_left || query_left > node_right {
        return new_node;
    }
    
    // Complete overlap
    if query_left <= node_left && node_right <= query_right {
        let range_size = (node_right - node_left + 1) as i64;
        tree.nodes[new_node as usize].sum_value = 
            tree.nodes[new_node as usize].sum_value * mult_value + add_value * range_size;
        tree.nodes[new_node as usize].lazy_mult = 
            tree.nodes[new_node as usize].lazy_mult * mult_value;
        tree.nodes[new_node as usize].lazy_add = 
            tree.nodes[new_node as usize].lazy_add * mult_value + add_value;
        return new_node;
    }
    
    // Partial overlap - recurse on children
    let left_child = tree.nodes[new_node as usize].left_child;
    let right_child = tree.nodes[new_node as usize].right_child;
    
    let new_left = update_range_recursive(tree, left_child, query_left, query_right, 
                                        add_value, mult_value, version);
    let new_right = update_range_recursive(tree, right_child, query_left, query_right, 
                                         add_value, mult_value, version);
    
    tree.nodes[new_node as usize].left_child = new_left;
    tree.nodes[new_node as usize].right_child = new_right;
    
    // Recalculate sum
    let left_sum = if new_left != -1 { 
        push_lazy_propagation(tree, new_left, version);
        tree.nodes[new_left as usize].sum_value 
    } else { 0 };
    let right_sum = if new_right != -1 { 
        push_lazy_propagation(tree, new_right, version);
        tree.nodes[new_right as usize].sum_value 
    } else { 0 };
    
    tree.nodes[new_node as usize].sum_value = left_sum + right_sum;
    
    return new_node;
}

// Query range sum with lazy propagation handling
fn query_range_recursive(tree: &mut PersistentSegmentTree,
                        node_idx: i32,
                        query_left: i32,
                        query_right: i32) -> i64 {
    if node_idx == -1 {
        return 0;
    }
    
    push_lazy_propagation(tree, node_idx, tree.current_version);
    
    let node_left = tree.nodes[node_idx as usize].range_left;
    let node_right = tree.nodes[node_idx as usize].range_right;
    
    // No intersection
    if query_right < node_left || query_left > node_right {
        return 0;
    }
    
    // Complete overlap
    if query_left <= node_left && node_right <= query_right {
        return tree.nodes[node_idx as usize].sum_value;
    }
    
    // Partial overlap
    let left_child = tree.nodes[node_idx as usize].left_child;
    let right_child = tree.nodes[node_idx as usize].right_child;
    
    let left_sum = query_range_recursive(tree, left_child, query_left, query_right);
    let right_sum = query_range_recursive(tree, right_child, query_left, query_right);
    
    return left_sum + right_sum;
}

// Complex nested operations with multiple version management
fn perform_complex_operations(tree: &mut PersistentSegmentTree) -> i64 {
    let mut total_sum = 0i64;
    let operations = 50;
    
    let mut op = 0;
    while op < operations {
        let version = tree.current_version + 1;
        tree.current_version = version;
        
        // Different types of operations in nested loops
        let mut inner_op = 0;
        while inner_op < 5 {
            let left = op % tree.array_size;
            let right = (op + inner_op + 1) % tree.array_size;
            
            let actual_left = if left < right { left } else { right };
            let actual_right = if left < right { right } else { left };
            
            if op % 3 == 0 {
                // Range addition
                let new_root = update_range_recursive(tree, 
                                                    tree.version_roots[(version - 1) as usize],
                                                    actual_left, actual_right, 
                                                    (op + 1) as i64, 1, version);
                tree.version_roots[version as usize] = new_root;
            } else if op % 3 == 1 {
                // Range multiplication
                let new_root = update_range_recursive(tree, 
                                                    tree.version_roots[(version - 1) as usize],
                                                    actual_left, actual_right, 
                                                    0, 2, version);
                tree.version_roots[version as usize] = new_root;
            } else {
                // Range query on previous version
                let query_version = if version > 1 { version - 1 } else { 0 };
                let sum = query_range_recursive(tree, 
                                              tree.version_roots[query_version as usize],
                                              actual_left, actual_right);
                total_sum = (total_sum + sum) % 1000000007;
            }
            inner_op += 1;
        }
        
        // Recursive analysis of version differences
        if version > 1 {
            total_sum += analyze_version_differences(tree, version - 1, version);
        }
        
        op += 1;
    }
    
    return total_sum;
}

// Analyze differences between versions recursively
fn analyze_version_differences(tree: &PersistentSegmentTree, 
                              old_version: i32, 
                              new_version: i32) -> i64 {
    let mut difference_score = 0i64;
    
    let mut i = 0;
    while i < tree.array_size {
        let old_sum = query_range_recursive_const(tree, 
                                                 tree.version_roots[old_version as usize],
                                                 i, i);
        let new_sum = query_range_recursive_const(tree, 
                                                 tree.version_roots[new_version as usize],
                                                 i, i);
        difference_score += (new_sum - old_sum).abs();
        i += 1;
    }
    
    return difference_score;
}

// Const version of query for analysis (doesn't modify tree)
fn query_range_recursive_const(tree: &PersistentSegmentTree,
                              node_idx: i32,
                              query_left: i32,
                              query_right: i32) -> i64 {
    if node_idx == -1 {
        return 0;
    }
    
    let node_left = tree.nodes[node_idx as usize].range_left;
    let node_right = tree.nodes[node_idx as usize].range_right;
    
    if query_right < node_left || query_left > node_right {
        return 0;
    }
    
    if query_left <= node_left && node_right <= query_right {
        return tree.nodes[node_idx as usize].sum_value;
    }
    
    let left_child = tree.nodes[node_idx as usize].left_child;
    let right_child = tree.nodes[node_idx as usize].right_child;
    
    return query_range_recursive_const(tree, left_child, query_left, query_right) +
           query_range_recursive_const(tree, right_child, query_left, query_right);
}

// FUNCTION NAME COLLISION: This function has the same name as one above
fn analyze_version_differences(tree: &PersistentSegmentTree, 
                              version1: i32, 
                              version2: i32,
                              depth: i32) -> i64 {  // ERROR: Function name collision
    if depth > 10 {
        return 0;
    }
    
    return analyze_version_differences(tree, version1, version2, depth + 1);
}

// Initialize persistent segment tree with base values
fn create_persistent_segment_tree(initial_values: [i64; 200], size: i32) -> PersistentSegmentTree {
    let mut tree = PersistentSegmentTree {
        nodes: [create_segment_node(0, 0, 0); 5000],
        node_count: 0,
        version_roots: [-1; 100],
        current_version: 0,
        base_array: initial_values,
        array_size: size,
    };
    
    // Build initial version
    let root = build_segment_tree_recursive(&mut tree, 0, size - 1, 0);
    tree.version_roots[0] = root;
    
    return tree;
}

// Main function with complex persistent operations
fn perform_persistent_analysis() -> i64 {
    // Initialize array with pattern: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
    let mut initial_array = [0i64; 200];
    let mut i = 0;
    while i < 200 {
        initial_array[i as usize] = ((i % 5) + 1) as i64;
        i += 1;
    }
    
    let mut tree = create_persistent_segment_tree(initial_array, 20);
    
    let operations_result = perform_complex_operations(&mut tree);
    
    // Historical query analysis
    let mut historical_sum = 0i64;
    i = 0;
    while i <= tree.current_version {
        let version_sum = query_range_recursive(&mut tree, 
                                              tree.version_roots[i as usize], 
                                              0, tree.array_size - 1);
        historical_sum += version_sum;
        i += 1;
    }
    
    return operations_result + historical_sum;
}

fn main() {
    let result = perform_persistent_analysis();
    printInt(result);
    exit(0);
}
