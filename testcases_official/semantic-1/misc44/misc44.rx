/*
Test Package: Semantic-1
Test Target: misc
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Success
Comment: Lenstra elliptic curve factorization method for composite numbers
*/

// Lenstra elliptic curve factorization method
// Uses elliptic curves to find factors of composite numbers
struct ECPoint {
    x: i32,
    y: i32,
    is_infinity: bool,
}

fn gcd(mut a: i32, mut b: i32) -> i32 {
    while (b != 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

fn extended_gcd(a: i32, b: i32, x: &mut i32, y: &mut i32) -> i32 {
    if (a == 0) {
        *x = 0;
        *y = 1;
        return b;
    }
    
    let mut x1 = 0;
    let mut y1 = 0;
    let gcd_val = extended_gcd(b % a, a, &mut x1, &mut y1);
    
    *x = y1 - (b / a) * x1;
    *y = x1;
    
    return gcd_val;
}

fn mod_inverse_safe(a: i32, m: i32) -> i32 {
    let mut x = 0;
    let mut y = 0;
    let g = extended_gcd(a, m, &mut x, &mut y);
    
    if (g != 1) {
        return -1; // No modular inverse exists
    }
    
    return if (x < 0) { x + m } else { x };
}

fn ec_point_add_lenstra(p1: ECPoint, p2: ECPoint, a: i32, n: i32) -> (ECPoint, i32) {
    if (p1.is_infinity) {
        return (p2, 1);
    }
    if (p2.is_infinity) {
        return (p1, 1);
    }
    
    if (p1.x == p2.x) {
        if (p1.y == p2.y) {
            // Point doubling
            let numerator = (3 * p1.x * p1.x + a) % n;
            let denominator = (2 * p1.y) % n;
            let inv = mod_inverse_safe(denominator, n);
            
            if (inv == -1) {
                return (ECPoint { x: 0, y: 0, is_infinity: true }, 
                       gcd(denominator, n));
            }
            
            let slope = (numerator * inv) % n;
            let x3 = (slope * slope - 2 * p1.x) % n;
            let y3 = (slope * (p1.x - x3) - p1.y) % n;
            
            return (ECPoint {
                x: if (x3 < 0) { x3 + n } else { x3 },
                y: if (y3 < 0) { y3 + n } else { y3 },
                is_infinity: false,
            }, 1);
        } else {
            return (ECPoint { x: 0, y: 0, is_infinity: true }, 1);
        }
    }
    
    let numerator = (p2.y - p1.y) % n;
    let denominator = (p2.x - p1.x) % n;
    let inv = mod_inverse_safe(denominator, n);
    
    if (inv == -1) {
        return (ECPoint { x: 0, y: 0, is_infinity: true }, 
               gcd(denominator, n));
    }
    
    let slope = (numerator * inv) % n;
    let x3 = (slope * slope - p1.x - p2.x) % n;
    let y3 = (slope * (p1.x - x3) - p1.y) % n;
    
    return (ECPoint {
        x: if (x3 < 0) { x3 + n } else { x3 },
        y: if (y3 < 0) { y3 + n } else { y3 },
        is_infinity: false,
    }, 1);
}

fn ec_scalar_multiply(mut k: i32, point: ECPoint, a: i32, n: i32) -> (ECPoint, i32) {
    let mut result = ECPoint { x: 0, y: 0, is_infinity: true };
    let mut addend = point;
    
    while (k > 0) {
        if (k % 2 == 1) {
            let (new_result, factor) = ec_point_add_lenstra(result, addend, a, n);
            result = new_result;
            if (factor > 1 && factor < n) {
                return (result, factor);
            }
        }
        
        let (doubled, factor) = ec_point_add_lenstra(addend, addend, a, n);
        addend = doubled;
        if (factor > 1 && factor < n) {
            return (addend, factor);
        }
        
        k = k / 2;
    }
    
    return (result, 1);
}

fn lenstra_factorization_recursive(n: i32, attempts: i32, max_attempts: i32) -> i32 {
    if (attempts >= max_attempts) {
        return n;
    }
    
    let a = (attempts * 7 + 1) % n;
    let x = (attempts * 11 + 2) % n;
    let y_squared = (x * x * x + a * x + attempts) % n;
    
    // Simple check if y_squared is a perfect square
    let mut y = 1;
    while (y * y <= y_squared) {
        if (y * y == y_squared) {
            break;
        }
        y = y + 1;
    }
    
    if (y * y != y_squared) {
        return lenstra_factorization_recursive(n, attempts + 1, max_attempts);
    }
    
    let point = ECPoint { x: x, y: y, is_infinity: false };
    
    // Try small factorial multiplications
    let mut k = 2;
    while (k <= 20) {
        let (_, factor) = ec_scalar_multiply(k, point, a, n);
        
        if (factor > 1 && factor < n) {
            return factor;
        }
        
        k = k + 1;
    }
    
    return lenstra_factorization_recursive(n, attempts + 1, max_attempts);
}

fn main() {
    let n = readInt();
    let factor = lenstra_factorization_recursive(n, 1, 10);
    printInt(factor);
    exit(0);
}
